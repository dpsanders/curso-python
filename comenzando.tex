\chapter{Comenzando con Python}

En este capítulo, empezaremos a explorar el lenguaje Python. Se darán las bases tanto de la sintáxis básica, como de las herramientas principales para escribir programas en el lenguaje. En todo el curso se hará énfasis en las aplicaciones al cómputo científico y a la enseñanza del mismo.

La versión de Python que ocuparemos es la 2.6. La nueva versión 3 rompe la compatibilidad con los paquetes básicos para el cómputo científico por el momento.


\section{El entorno \texttt{ipython}}

El entorno principal que ocuparemos para trabajar de manera interactiva es \texttt{ipython}. Otro posible es \texttt{idle}.

\texttt{ipython} está diseñado para maximar la productividad al utilizar Python.
En particular, tiene ciertos comandos que no existen en otros interpretadores de Python.
Uno muy útil es
\begin{python}
In [1]: logstart primero_log.py
\end{python}
Este comando graba un ``log'' (bitácora) de  todo lo que se teclea en la sesión actual en el archivo dado, aqui \inl{primero_log.py}.

Otra función de suma utilidad en \texttt{ipython} es que la de completar palabras parciales con la tecla \inl{<TAB>}.
Además, los comandos \inl{who} y \inl{whos} proveen información de las funciones nuevas agregadas en la sesión.

La documentación para cualquier función o comando está disponible en \inl{ipython} al poner \inl{?}, por ejemplo
\begin{python}
who?
\end{python}
Para funciones, \inl{??} muestra el código fuente de la función, cuando está disponible.


\section{Aritmética}
Python se puede utilizar como una calculadora:
\begin{python}
3
3 + 2
3 * (-7.1 + 10**2)
\end{python}
Aquí, \inl{**} indica una potencia, como en Fortran, y las paréntesis alteran la prioridad en las operaciones.


Es necesario\footnote{En Python 2.6; la situación cambia en Python 3.} tener cuidado al hacer manipulaciones con enteros:
\begin{python}
1 / 2
3 / 2
5 / 2
\end{python}
ya que el resultado se redondea al entero más cercano. Para evitar eso, basta un punto decimal:
\begin{python}
1 / 2.
\end{python}


Los números sin punto decimal se consideran enteros, y los con punto decimal flotantes (de doble precisión).
Los enteros pueden ser \emph{arbitrariamente grandes}:
\begin{python}
2 ** 2 ** 2 ** 2 ** 2
\end{python}



Python cuenta con números complejos, utilizando la notación \inl{1j} para la raiz de $-1$:
\begin{python}
1 + 3j
1j * 1j
j    # da un error
\end{python}
`\inl{#}' indica un comentario que se extiende hasta el final de la línea.



\section{Variables}
Para llevar a cabo cálculos, necesitamos \defn{variables}. Las variables se declaran como debe de ser:
\begin{python}
a = 3
b = 17.5
c = 1 + 3j

print a + b / c
\end{python}
Python reconece de manera \emph{automática} el tipo de la variable según su forma.
El comando \inl{print} imprime su argumento de una manera bonita.

Al reasignar una variable, se pierde la información de su valor interior, incluyendo el tipo:
\begin{python}
a = 3
a = -5.5
\end{python}


\section{Entrada por parte del usuario}
Se puede pedir información del usuario con
\begin{python}
a = raw_input('Dame el valor de a: ')
print "El cuadrado de a es ", a*a
\end{python}
Las cadenas en Python son cadenas de caracteres entre apóstrofes o comillas. 






\section{Listas}
La estructura de datos principal en Python es la \defn{lista}. Consiste literalmente en una lista ordenada de cosas, y reemplaza a los arreglos en otros lenguajes. La diferencia es que las listas en Python son automáticamente de longitud \emph{variable}, y pueden contener objetos de \emph{cualquier} tipo.

Una lista se define con corchetes (\inl{[} y \inl{\}):
\begin{python}
l = [3, 4, 6]
\end{python}
Puede contener cualquier cosa, <incluyendo a otras listas!:
\begin{python}
l = [3.5, -1, "hola", [1.0, [3, 17]]]
\end{python}
Por lo tanto, es una estructura de datos muy sencillo.

Los elementos de la lista se pueden extraer y cambiar usando la notación \inl{l[i]},
donde \inl{i} indica el número del elemento, empezando desde $0$:
\begin{python}
l = [1, 2, 3]
print l[0], l[1]
l[0] = 5
l
\end{python}

Se pueden manipular rebanadas (``slices'') de la lista con la notación \inl{l[1:3]}:
\begin{python}
l = [1, 2, 3, 6, 7]
l[1:3]
l[:3]
l[3:]
\end{python}

\ej >Qué hace \inl{l[-1]}?

La longitud de una lista se puede encontrar con
\begin{python}
len(l)
\end{python}
Se pueden agregar elementos a la lista con
\begin{python}
l = []	  # lista vacia
l.append(17)
l.append(3)
print l, len(l)
\end{python}

Como siempre, las otras operaciones que se pueden llevar a cabo con la lista se pueden
averiguar en \inl{ipython} con \inl{l.<TAB>}.

\section{$n$-adas / tuples}
Otra estructura parecida es una $n$-ada (``tuple'').
Es parecido a una lista, pero se escribe con (o incluso, a veces, sin paréntesis), y no se puede modificar:
\begin{python}
t = (3, 5)
t[0]
t[0] = 1	# error!
\end{python}

Las $n$-adas se utilizan para agrupar información. Se pueden asignar como sigue:
\begin{python}
a, b = 3, 5
print a; print b
\end{python}



\section{La biblioteca estándar}
Python tiene una biblioteca estándar amplia, lo cual siempre está disponible en cualquier instalación de Python.
La documentación para esta biblioteca está disponible en \url{http://docs.python.org/library/}

Por ejemplo, la sección 9 incluye información sobre el módulo \inl{fractions}:
\begin{python}
from fractions import Fraction

a = Fraction(3, 5)
b = Fraction(1)
c = a + b
d = Fraction(4, 6)
d
e = a + d
\end{python}

Cada `cosa' en Python es un \defn{objeto}, que tiene propiedades y operaciones disponibles.
\inl{Fraction} es un tipo de objeto (\defn{clase}); sus operaciones están disponibles en \inl{ipython} a través de
\inl{Fraction.<TAB>}. Las que empiezan con \inl{__} son internos y deberían de ignorarse por el momento; las demás son accesibles al usuario.



\section{Programitas de Python: scripts}
Una vez que las secuencias de comandos se complican, es útil poder guardarlos en un programa, o \defn{script}.
Eso consiste en un archivo de texto, cuyo nombre termina en \inl{.py}, donde se guarda la secuencia de comandos.

Por ejemplo, guardemos el código anterior en el archivo \inl{cuad.py}
Podemos correr el código desde \inl{ipython} con
\begin{python}
run cuad
\end{python}
Al terminar de correr el programa, el control regresa a \inl{ipython}, pero todavía tenemos acceso a las variables y funciones definidas en el script.

Alternativamente, podemos tratar el script como un programa en sí al ejecutar desde el shell
\begin{python}
python cuad.py
\end{python}
Al terminar, el control regresa al shell, y perdemos la información adentro del script.

De hecho, un script se puede considerar un módulo en sí, que también se puede importar:
\begin{python}
from cuad import *
\end{python}



